// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/orgms/api/org.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateCompanyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateCompanyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCompanyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCompanyReqMultiError, or nil if none found.
func (m *CreateCompanyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCompanyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCompanyName()); l < 1 || l > 100 {
		err := CreateCompanyReqValidationError{
			field:  "CompanyName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCompanyCode()); l < 1 || l > 100 {
		err := CreateCompanyReqValidationError{
			field:  "CompanyCode",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CompanyType

	// no validation rules for CompanyDesc

	if m.GetIsVirtual() != 0 {

		if _, ok := _CreateCompanyReq_IsVirtual_InLookup[m.GetIsVirtual()]; !ok {
			err := CreateCompanyReqValidationError{
				field:  "IsVirtual",
				reason: "value must be in list [0 1]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetStatus() != 0 {

		if _, ok := _CreateCompanyReq_Status_InLookup[m.GetStatus()]; !ok {
			err := CreateCompanyReqValidationError{
				field:  "Status",
				reason: "value must be in list [0 1]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateCompanyReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateCompanyReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateCompanyReqValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateCompanyReqMultiError(errors)
	}

	return nil
}

// CreateCompanyReqMultiError is an error wrapping multiple validation errors
// returned by CreateCompanyReq.ValidateAll() if the designated constraints
// aren't met.
type CreateCompanyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCompanyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCompanyReqMultiError) AllErrors() []error { return m }

// CreateCompanyReqValidationError is the validation error returned by
// CreateCompanyReq.Validate if the designated constraints aren't met.
type CreateCompanyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCompanyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCompanyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCompanyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCompanyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCompanyReqValidationError) ErrorName() string { return "CreateCompanyReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateCompanyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCompanyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCompanyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCompanyReqValidationError{}

var _CreateCompanyReq_IsVirtual_InLookup = map[int64]struct{}{
	0: {},
	1: {},
}

var _CreateCompanyReq_Status_InLookup = map[int64]struct{}{
	0: {},
	1: {},
}

// Validate checks the field values on CreateCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCompanyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCompanyReplyMultiError, or nil if none found.
func (m *CreateCompanyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCompanyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateCompanyReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateCompanyReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateCompanyReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateCompanyReplyMultiError(errors)
	}

	return nil
}

// CreateCompanyReplyMultiError is an error wrapping multiple validation errors
// returned by CreateCompanyReply.ValidateAll() if the designated constraints
// aren't met.
type CreateCompanyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCompanyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCompanyReplyMultiError) AllErrors() []error { return m }

// CreateCompanyReplyValidationError is the validation error returned by
// CreateCompanyReply.Validate if the designated constraints aren't met.
type CreateCompanyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCompanyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCompanyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCompanyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCompanyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCompanyReplyValidationError) ErrorName() string {
	return "CreateCompanyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCompanyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCompanyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCompanyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCompanyReplyValidationError{}

// Validate checks the field values on AttrReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AttrReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttrReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AttrReqMultiError, or nil if none found.
func (m *AttrReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AttrReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AttrName

	// no validation rules for AttrValue

	if len(errors) > 0 {
		return AttrReqMultiError(errors)
	}

	return nil
}

// AttrReqMultiError is an error wrapping multiple validation errors returned
// by AttrReq.ValidateAll() if the designated constraints aren't met.
type AttrReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttrReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttrReqMultiError) AllErrors() []error { return m }

// AttrReqValidationError is the validation error returned by AttrReq.Validate
// if the designated constraints aren't met.
type AttrReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttrReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttrReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttrReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttrReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttrReqValidationError) ErrorName() string { return "AttrReqValidationError" }

// Error satisfies the builtin error interface
func (e AttrReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttrReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttrReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttrReqValidationError{}

// Validate checks the field values on BatchCreateCompanyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchCreateCompanyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchCreateCompanyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchCreateCompanyReqMultiError, or nil if none found.
func (m *BatchCreateCompanyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchCreateCompanyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCompanyList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchCreateCompanyReqValidationError{
						field:  fmt.Sprintf("CompanyList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchCreateCompanyReqValidationError{
						field:  fmt.Sprintf("CompanyList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchCreateCompanyReqValidationError{
					field:  fmt.Sprintf("CompanyList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchCreateCompanyReqMultiError(errors)
	}

	return nil
}

// BatchCreateCompanyReqMultiError is an error wrapping multiple validation
// errors returned by BatchCreateCompanyReq.ValidateAll() if the designated
// constraints aren't met.
type BatchCreateCompanyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchCreateCompanyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchCreateCompanyReqMultiError) AllErrors() []error { return m }

// BatchCreateCompanyReqValidationError is the validation error returned by
// BatchCreateCompanyReq.Validate if the designated constraints aren't met.
type BatchCreateCompanyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchCreateCompanyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchCreateCompanyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchCreateCompanyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchCreateCompanyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchCreateCompanyReqValidationError) ErrorName() string {
	return "BatchCreateCompanyReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchCreateCompanyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchCreateCompanyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchCreateCompanyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchCreateCompanyReqValidationError{}

// Validate checks the field values on BatchCreateCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchCreateCompanyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchCreateCompanyReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchCreateCompanyReplyMultiError, or nil if none found.
func (m *BatchCreateCompanyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchCreateCompanyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetData()))
		i := 0
		for key := range m.GetData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetData()[key]
			_ = val

			// no validation rules for Data[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BatchCreateCompanyReplyValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BatchCreateCompanyReplyValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BatchCreateCompanyReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Total

	if len(errors) > 0 {
		return BatchCreateCompanyReplyMultiError(errors)
	}

	return nil
}

// BatchCreateCompanyReplyMultiError is an error wrapping multiple validation
// errors returned by BatchCreateCompanyReply.ValidateAll() if the designated
// constraints aren't met.
type BatchCreateCompanyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchCreateCompanyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchCreateCompanyReplyMultiError) AllErrors() []error { return m }

// BatchCreateCompanyReplyValidationError is the validation error returned by
// BatchCreateCompanyReply.Validate if the designated constraints aren't met.
type BatchCreateCompanyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchCreateCompanyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchCreateCompanyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchCreateCompanyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchCreateCompanyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchCreateCompanyReplyValidationError) ErrorName() string {
	return "BatchCreateCompanyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchCreateCompanyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchCreateCompanyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchCreateCompanyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchCreateCompanyReplyValidationError{}

// Validate checks the field values on GetCompanyListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCompanyListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCompanyListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCompanyListReqMultiError, or nil if none found.
func (m *GetCompanyListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCompanyListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageNum

	if len(errors) > 0 {
		return GetCompanyListReqMultiError(errors)
	}

	return nil
}

// GetCompanyListReqMultiError is an error wrapping multiple validation errors
// returned by GetCompanyListReq.ValidateAll() if the designated constraints
// aren't met.
type GetCompanyListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCompanyListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCompanyListReqMultiError) AllErrors() []error { return m }

// GetCompanyListReqValidationError is the validation error returned by
// GetCompanyListReq.Validate if the designated constraints aren't met.
type GetCompanyListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCompanyListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCompanyListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCompanyListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCompanyListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCompanyListReqValidationError) ErrorName() string {
	return "GetCompanyListReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetCompanyListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCompanyListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCompanyListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCompanyListReqValidationError{}

// Validate checks the field values on GetCompanyListReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCompanyListReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCompanyListReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCompanyListReplyMultiError, or nil if none found.
func (m *GetCompanyListReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCompanyListReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCompanyListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCompanyListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCompanyListReplyValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for PageSize

	// no validation rules for PageNum

	if len(errors) > 0 {
		return GetCompanyListReplyMultiError(errors)
	}

	return nil
}

// GetCompanyListReplyMultiError is an error wrapping multiple validation
// errors returned by GetCompanyListReply.ValidateAll() if the designated
// constraints aren't met.
type GetCompanyListReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCompanyListReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCompanyListReplyMultiError) AllErrors() []error { return m }

// GetCompanyListReplyValidationError is the validation error returned by
// GetCompanyListReply.Validate if the designated constraints aren't met.
type GetCompanyListReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCompanyListReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCompanyListReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCompanyListReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCompanyListReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCompanyListReplyValidationError) ErrorName() string {
	return "GetCompanyListReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetCompanyListReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCompanyListReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCompanyListReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCompanyListReplyValidationError{}

// Validate checks the field values on GetCompanyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetCompanyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCompanyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetCompanyReqMultiError, or
// nil if none found.
func (m *GetCompanyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCompanyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	if len(errors) > 0 {
		return GetCompanyReqMultiError(errors)
	}

	return nil
}

// GetCompanyReqMultiError is an error wrapping multiple validation errors
// returned by GetCompanyReq.ValidateAll() if the designated constraints
// aren't met.
type GetCompanyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCompanyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCompanyReqMultiError) AllErrors() []error { return m }

// GetCompanyReqValidationError is the validation error returned by
// GetCompanyReq.Validate if the designated constraints aren't met.
type GetCompanyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCompanyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCompanyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCompanyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCompanyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCompanyReqValidationError) ErrorName() string { return "GetCompanyReqValidationError" }

// Error satisfies the builtin error interface
func (e GetCompanyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCompanyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCompanyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCompanyReqValidationError{}

// Validate checks the field values on GetCompanyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCompanyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCompanyReplyMultiError, or nil if none found.
func (m *GetCompanyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCompanyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCompanyReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCompanyReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCompanyReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCompanyReplyMultiError(errors)
	}

	return nil
}

// GetCompanyReplyMultiError is an error wrapping multiple validation errors
// returned by GetCompanyReply.ValidateAll() if the designated constraints
// aren't met.
type GetCompanyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCompanyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCompanyReplyMultiError) AllErrors() []error { return m }

// GetCompanyReplyValidationError is the validation error returned by
// GetCompanyReply.Validate if the designated constraints aren't met.
type GetCompanyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCompanyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCompanyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCompanyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCompanyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCompanyReplyValidationError) ErrorName() string { return "GetCompanyReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetCompanyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCompanyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCompanyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCompanyReplyValidationError{}

// Validate checks the field values on UpdateCompanyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateCompanyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCompanyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCompanyReqMultiError, or nil if none found.
func (m *UpdateCompanyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCompanyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCompanyReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCompanyReqValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCompanyReqValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCompanyReqMultiError(errors)
	}

	return nil
}

// UpdateCompanyReqMultiError is an error wrapping multiple validation errors
// returned by UpdateCompanyReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateCompanyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCompanyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCompanyReqMultiError) AllErrors() []error { return m }

// UpdateCompanyReqValidationError is the validation error returned by
// UpdateCompanyReq.Validate if the designated constraints aren't met.
type UpdateCompanyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCompanyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCompanyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCompanyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCompanyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCompanyReqValidationError) ErrorName() string { return "UpdateCompanyReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateCompanyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCompanyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCompanyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCompanyReqValidationError{}

// Validate checks the field values on UpdateCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateCompanyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateCompanyReplyMultiError, or nil if none found.
func (m *UpdateCompanyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateCompanyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateCompanyReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateCompanyReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateCompanyReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateCompanyReplyMultiError(errors)
	}

	return nil
}

// UpdateCompanyReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateCompanyReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateCompanyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateCompanyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateCompanyReplyMultiError) AllErrors() []error { return m }

// UpdateCompanyReplyValidationError is the validation error returned by
// UpdateCompanyReply.Validate if the designated constraints aren't met.
type UpdateCompanyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateCompanyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateCompanyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateCompanyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateCompanyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateCompanyReplyValidationError) ErrorName() string {
	return "UpdateCompanyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateCompanyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateCompanyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateCompanyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateCompanyReplyValidationError{}

// Validate checks the field values on DelCompanyReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DelCompanyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelCompanyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DelCompanyReqMultiError, or
// nil if none found.
func (m *DelCompanyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DelCompanyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	if len(errors) > 0 {
		return DelCompanyReqMultiError(errors)
	}

	return nil
}

// DelCompanyReqMultiError is an error wrapping multiple validation errors
// returned by DelCompanyReq.ValidateAll() if the designated constraints
// aren't met.
type DelCompanyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelCompanyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelCompanyReqMultiError) AllErrors() []error { return m }

// DelCompanyReqValidationError is the validation error returned by
// DelCompanyReq.Validate if the designated constraints aren't met.
type DelCompanyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelCompanyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelCompanyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelCompanyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelCompanyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelCompanyReqValidationError) ErrorName() string { return "DelCompanyReqValidationError" }

// Error satisfies the builtin error interface
func (e DelCompanyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelCompanyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelCompanyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelCompanyReqValidationError{}

// Validate checks the field values on DelCompanyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DelCompanyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DelCompanyReplyMultiError, or nil if none found.
func (m *DelCompanyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DelCompanyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	if len(errors) > 0 {
		return DelCompanyReplyMultiError(errors)
	}

	return nil
}

// DelCompanyReplyMultiError is an error wrapping multiple validation errors
// returned by DelCompanyReply.ValidateAll() if the designated constraints
// aren't met.
type DelCompanyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelCompanyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelCompanyReplyMultiError) AllErrors() []error { return m }

// DelCompanyReplyValidationError is the validation error returned by
// DelCompanyReply.Validate if the designated constraints aren't met.
type DelCompanyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelCompanyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelCompanyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelCompanyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelCompanyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelCompanyReplyValidationError) ErrorName() string { return "DelCompanyReplyValidationError" }

// Error satisfies the builtin error interface
func (e DelCompanyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelCompanyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelCompanyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelCompanyReplyValidationError{}

// Validate checks the field values on OrderCompanyReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderCompanyReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderCompanyReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderCompanyReqMultiError, or nil if none found.
func (m *OrderCompanyReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderCompanyReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OrderCompanyReqMultiError(errors)
	}

	return nil
}

// OrderCompanyReqMultiError is an error wrapping multiple validation errors
// returned by OrderCompanyReq.ValidateAll() if the designated constraints
// aren't met.
type OrderCompanyReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderCompanyReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderCompanyReqMultiError) AllErrors() []error { return m }

// OrderCompanyReqValidationError is the validation error returned by
// OrderCompanyReq.Validate if the designated constraints aren't met.
type OrderCompanyReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderCompanyReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderCompanyReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderCompanyReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderCompanyReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderCompanyReqValidationError) ErrorName() string { return "OrderCompanyReqValidationError" }

// Error satisfies the builtin error interface
func (e OrderCompanyReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderCompanyReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderCompanyReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderCompanyReqValidationError{}

// Validate checks the field values on OrderCompanyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderCompanyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderCompanyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderCompanyReplyMultiError, or nil if none found.
func (m *OrderCompanyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderCompanyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OrderCompanyReplyMultiError(errors)
	}

	return nil
}

// OrderCompanyReplyMultiError is an error wrapping multiple validation errors
// returned by OrderCompanyReply.ValidateAll() if the designated constraints
// aren't met.
type OrderCompanyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderCompanyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderCompanyReplyMultiError) AllErrors() []error { return m }

// OrderCompanyReplyValidationError is the validation error returned by
// OrderCompanyReply.Validate if the designated constraints aren't met.
type OrderCompanyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderCompanyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderCompanyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderCompanyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderCompanyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderCompanyReplyValidationError) ErrorName() string {
	return "OrderCompanyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e OrderCompanyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderCompanyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderCompanyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderCompanyReplyValidationError{}

// Validate checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyInfoMultiError, or
// nil if none found.
func (m *CompanyInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	// no validation rules for CompanyName

	// no validation rules for CompanyCode

	// no validation rules for CompanyType

	// no validation rules for CompanyDesc

	// no validation rules for Seq

	// no validation rules for IsVirtual

	// no validation rules for DelFlag

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompanyInfoValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CompanyInfoMultiError(errors)
	}

	return nil
}

// CompanyInfoMultiError is an error wrapping multiple validation errors
// returned by CompanyInfo.ValidateAll() if the designated constraints aren't met.
type CompanyInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyInfoMultiError) AllErrors() []error { return m }

// CompanyInfoValidationError is the validation error returned by
// CompanyInfo.Validate if the designated constraints aren't met.
type CompanyInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyInfoValidationError) ErrorName() string { return "CompanyInfoValidationError" }

// Error satisfies the builtin error interface
func (e CompanyInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyInfoValidationError{}

// Validate checks the field values on CreateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDepartmentReqMultiError, or nil if none found.
func (m *CreateDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	// no validation rules for DepartmentName

	// no validation rules for DepartmentDesc

	// no validation rules for DepartmentType

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Status

	// no validation rules for IsVirtual

	// no validation rules for ParentId

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDepartmentReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDepartmentReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDepartmentReqValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDepartmentReqMultiError(errors)
	}

	return nil
}

// CreateDepartmentReqMultiError is an error wrapping multiple validation
// errors returned by CreateDepartmentReq.ValidateAll() if the designated
// constraints aren't met.
type CreateDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDepartmentReqMultiError) AllErrors() []error { return m }

// CreateDepartmentReqValidationError is the validation error returned by
// CreateDepartmentReq.Validate if the designated constraints aren't met.
type CreateDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDepartmentReqValidationError) ErrorName() string {
	return "CreateDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDepartmentReqValidationError{}

// Validate checks the field values on CreateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDepartmentReplyMultiError, or nil if none found.
func (m *CreateDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDepartmentReplyMultiError(errors)
	}

	return nil
}

// CreateDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by CreateDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type CreateDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDepartmentReplyMultiError) AllErrors() []error { return m }

// CreateDepartmentReplyValidationError is the validation error returned by
// CreateDepartmentReply.Validate if the designated constraints aren't met.
type CreateDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDepartmentReplyValidationError) ErrorName() string {
	return "CreateDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDepartmentReplyValidationError{}

// Validate checks the field values on BatchCreateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchCreateDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchCreateDepartmentReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchCreateDepartmentReqMultiError, or nil if none found.
func (m *BatchCreateDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchCreateDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDepartmentList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchCreateDepartmentReqValidationError{
						field:  fmt.Sprintf("DepartmentList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchCreateDepartmentReqValidationError{
						field:  fmt.Sprintf("DepartmentList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchCreateDepartmentReqValidationError{
					field:  fmt.Sprintf("DepartmentList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchCreateDepartmentReqMultiError(errors)
	}

	return nil
}

// BatchCreateDepartmentReqMultiError is an error wrapping multiple validation
// errors returned by BatchCreateDepartmentReq.ValidateAll() if the designated
// constraints aren't met.
type BatchCreateDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchCreateDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchCreateDepartmentReqMultiError) AllErrors() []error { return m }

// BatchCreateDepartmentReqValidationError is the validation error returned by
// BatchCreateDepartmentReq.Validate if the designated constraints aren't met.
type BatchCreateDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchCreateDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchCreateDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchCreateDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchCreateDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchCreateDepartmentReqValidationError) ErrorName() string {
	return "BatchCreateDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchCreateDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchCreateDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchCreateDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchCreateDepartmentReqValidationError{}

// Validate checks the field values on BatchCreateDepartmentReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchCreateDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchCreateDepartmentReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchCreateDepartmentReplyMultiError, or nil if none found.
func (m *BatchCreateDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchCreateDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetData()))
		i := 0
		for key := range m.GetData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetData()[key]
			_ = val

			// no validation rules for Data[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BatchCreateDepartmentReplyValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BatchCreateDepartmentReplyValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BatchCreateDepartmentReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return BatchCreateDepartmentReplyMultiError(errors)
	}

	return nil
}

// BatchCreateDepartmentReplyMultiError is an error wrapping multiple
// validation errors returned by BatchCreateDepartmentReply.ValidateAll() if
// the designated constraints aren't met.
type BatchCreateDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchCreateDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchCreateDepartmentReplyMultiError) AllErrors() []error { return m }

// BatchCreateDepartmentReplyValidationError is the validation error returned
// by BatchCreateDepartmentReply.Validate if the designated constraints aren't met.
type BatchCreateDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchCreateDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchCreateDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchCreateDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchCreateDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchCreateDepartmentReplyValidationError) ErrorName() string {
	return "BatchCreateDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchCreateDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchCreateDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchCreateDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchCreateDepartmentReplyValidationError{}

// Validate checks the field values on UpdateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDepartmentReqMultiError, or nil if none found.
func (m *UpdateDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	// no validation rules for DepartmentName

	// no validation rules for DepartmentDesc

	// no validation rules for DepartmentType

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Status

	// no validation rules for IsVirtual

	// no validation rules for ParentId

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDepartmentReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDepartmentReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDepartmentReqValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateDepartmentReqMultiError(errors)
	}

	return nil
}

// UpdateDepartmentReqMultiError is an error wrapping multiple validation
// errors returned by UpdateDepartmentReq.ValidateAll() if the designated
// constraints aren't met.
type UpdateDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDepartmentReqMultiError) AllErrors() []error { return m }

// UpdateDepartmentReqValidationError is the validation error returned by
// UpdateDepartmentReq.Validate if the designated constraints aren't met.
type UpdateDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDepartmentReqValidationError) ErrorName() string {
	return "UpdateDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDepartmentReqValidationError{}

// Validate checks the field values on UpdateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDepartmentReplyMultiError, or nil if none found.
func (m *UpdateDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDepartmentReplyMultiError(errors)
	}

	return nil
}

// UpdateDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by UpdateDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type UpdateDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDepartmentReplyMultiError) AllErrors() []error { return m }

// UpdateDepartmentReplyValidationError is the validation error returned by
// UpdateDepartmentReply.Validate if the designated constraints aren't met.
type UpdateDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDepartmentReplyValidationError) ErrorName() string {
	return "UpdateDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDepartmentReplyValidationError{}

// Validate checks the field values on GetDepartmentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDepartmentReqMultiError, or nil if none found.
func (m *GetDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	if len(errors) > 0 {
		return GetDepartmentReqMultiError(errors)
	}

	return nil
}

// GetDepartmentReqMultiError is an error wrapping multiple validation errors
// returned by GetDepartmentReq.ValidateAll() if the designated constraints
// aren't met.
type GetDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepartmentReqMultiError) AllErrors() []error { return m }

// GetDepartmentReqValidationError is the validation error returned by
// GetDepartmentReq.Validate if the designated constraints aren't met.
type GetDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepartmentReqValidationError) ErrorName() string { return "GetDepartmentReqValidationError" }

// Error satisfies the builtin error interface
func (e GetDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepartmentReqValidationError{}

// Validate checks the field values on GetDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDepartmentReplyMultiError, or nil if none found.
func (m *GetDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDepartmentReplyMultiError(errors)
	}

	return nil
}

// GetDepartmentReplyMultiError is an error wrapping multiple validation errors
// returned by GetDepartmentReply.ValidateAll() if the designated constraints
// aren't met.
type GetDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepartmentReplyMultiError) AllErrors() []error { return m }

// GetDepartmentReplyValidationError is the validation error returned by
// GetDepartmentReply.Validate if the designated constraints aren't met.
type GetDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepartmentReplyValidationError) ErrorName() string {
	return "GetDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepartmentReplyValidationError{}

// Validate checks the field values on GetDepartmentListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDepartmentListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepartmentListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDepartmentListReqMultiError, or nil if none found.
func (m *GetDepartmentListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepartmentListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageNum

	if len(errors) > 0 {
		return GetDepartmentListReqMultiError(errors)
	}

	return nil
}

// GetDepartmentListReqMultiError is an error wrapping multiple validation
// errors returned by GetDepartmentListReq.ValidateAll() if the designated
// constraints aren't met.
type GetDepartmentListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepartmentListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepartmentListReqMultiError) AllErrors() []error { return m }

// GetDepartmentListReqValidationError is the validation error returned by
// GetDepartmentListReq.Validate if the designated constraints aren't met.
type GetDepartmentListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepartmentListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepartmentListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepartmentListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepartmentListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepartmentListReqValidationError) ErrorName() string {
	return "GetDepartmentListReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetDepartmentListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepartmentListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepartmentListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepartmentListReqValidationError{}

// Validate checks the field values on GetDepartmentListReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDepartmentListReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDepartmentListReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDepartmentListReplyMultiError, or nil if none found.
func (m *GetDepartmentListReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDepartmentListReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDepartmentListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDepartmentListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDepartmentListReplyValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for PageSize

	// no validation rules for PageNum

	if len(errors) > 0 {
		return GetDepartmentListReplyMultiError(errors)
	}

	return nil
}

// GetDepartmentListReplyMultiError is an error wrapping multiple validation
// errors returned by GetDepartmentListReply.ValidateAll() if the designated
// constraints aren't met.
type GetDepartmentListReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDepartmentListReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDepartmentListReplyMultiError) AllErrors() []error { return m }

// GetDepartmentListReplyValidationError is the validation error returned by
// GetDepartmentListReply.Validate if the designated constraints aren't met.
type GetDepartmentListReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDepartmentListReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDepartmentListReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDepartmentListReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDepartmentListReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDepartmentListReplyValidationError) ErrorName() string {
	return "GetDepartmentListReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetDepartmentListReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDepartmentListReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDepartmentListReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDepartmentListReplyValidationError{}

// Validate checks the field values on DelDepartmentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DelDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DelDepartmentReqMultiError, or nil if none found.
func (m *DelDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DelDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	if len(errors) > 0 {
		return DelDepartmentReqMultiError(errors)
	}

	return nil
}

// DelDepartmentReqMultiError is an error wrapping multiple validation errors
// returned by DelDepartmentReq.ValidateAll() if the designated constraints
// aren't met.
type DelDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelDepartmentReqMultiError) AllErrors() []error { return m }

// DelDepartmentReqValidationError is the validation error returned by
// DelDepartmentReq.Validate if the designated constraints aren't met.
type DelDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelDepartmentReqValidationError) ErrorName() string { return "DelDepartmentReqValidationError" }

// Error satisfies the builtin error interface
func (e DelDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelDepartmentReqValidationError{}

// Validate checks the field values on DelDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DelDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DelDepartmentReplyMultiError, or nil if none found.
func (m *DelDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DelDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	if len(errors) > 0 {
		return DelDepartmentReplyMultiError(errors)
	}

	return nil
}

// DelDepartmentReplyMultiError is an error wrapping multiple validation errors
// returned by DelDepartmentReply.ValidateAll() if the designated constraints
// aren't met.
type DelDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelDepartmentReplyMultiError) AllErrors() []error { return m }

// DelDepartmentReplyValidationError is the validation error returned by
// DelDepartmentReply.Validate if the designated constraints aren't met.
type DelDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelDepartmentReplyValidationError) ErrorName() string {
	return "DelDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DelDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelDepartmentReplyValidationError{}

// Validate checks the field values on AssignDepartmentUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssignDepartmentUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssignDepartmentUserReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssignDepartmentUserReqMultiError, or nil if none found.
func (m *AssignDepartmentUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AssignDepartmentUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	if len(errors) > 0 {
		return AssignDepartmentUserReqMultiError(errors)
	}

	return nil
}

// AssignDepartmentUserReqMultiError is an error wrapping multiple validation
// errors returned by AssignDepartmentUserReq.ValidateAll() if the designated
// constraints aren't met.
type AssignDepartmentUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssignDepartmentUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssignDepartmentUserReqMultiError) AllErrors() []error { return m }

// AssignDepartmentUserReqValidationError is the validation error returned by
// AssignDepartmentUserReq.Validate if the designated constraints aren't met.
type AssignDepartmentUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssignDepartmentUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssignDepartmentUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssignDepartmentUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssignDepartmentUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssignDepartmentUserReqValidationError) ErrorName() string {
	return "AssignDepartmentUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e AssignDepartmentUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssignDepartmentUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssignDepartmentUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssignDepartmentUserReqValidationError{}

// Validate checks the field values on AssignDepartmentUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssignDepartmentUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssignDepartmentUserReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssignDepartmentUserReplyMultiError, or nil if none found.
func (m *AssignDepartmentUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *AssignDepartmentUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	if len(errors) > 0 {
		return AssignDepartmentUserReplyMultiError(errors)
	}

	return nil
}

// AssignDepartmentUserReplyMultiError is an error wrapping multiple validation
// errors returned by AssignDepartmentUserReply.ValidateAll() if the
// designated constraints aren't met.
type AssignDepartmentUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssignDepartmentUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssignDepartmentUserReplyMultiError) AllErrors() []error { return m }

// AssignDepartmentUserReplyValidationError is the validation error returned by
// AssignDepartmentUserReply.Validate if the designated constraints aren't met.
type AssignDepartmentUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssignDepartmentUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssignDepartmentUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssignDepartmentUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssignDepartmentUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssignDepartmentUserReplyValidationError) ErrorName() string {
	return "AssignDepartmentUserReplyValidationError"
}

// Error satisfies the builtin error interface
func (e AssignDepartmentUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssignDepartmentUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssignDepartmentUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssignDepartmentUserReplyValidationError{}

// Validate checks the field values on MoveDepartmentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MoveDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveDepartmentReqMultiError, or nil if none found.
func (m *MoveDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	// no validation rules for FromParentId

	// no validation rules for ToParentId

	if len(errors) > 0 {
		return MoveDepartmentReqMultiError(errors)
	}

	return nil
}

// MoveDepartmentReqMultiError is an error wrapping multiple validation errors
// returned by MoveDepartmentReq.ValidateAll() if the designated constraints
// aren't met.
type MoveDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveDepartmentReqMultiError) AllErrors() []error { return m }

// MoveDepartmentReqValidationError is the validation error returned by
// MoveDepartmentReq.Validate if the designated constraints aren't met.
type MoveDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveDepartmentReqValidationError) ErrorName() string {
	return "MoveDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e MoveDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveDepartmentReqValidationError{}

// Validate checks the field values on MoveDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MoveDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MoveDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MoveDepartmentReplyMultiError, or nil if none found.
func (m *MoveDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *MoveDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MoveDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MoveDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MoveDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MoveDepartmentReplyMultiError(errors)
	}

	return nil
}

// MoveDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by MoveDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type MoveDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MoveDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MoveDepartmentReplyMultiError) AllErrors() []error { return m }

// MoveDepartmentReplyValidationError is the validation error returned by
// MoveDepartmentReply.Validate if the designated constraints aren't met.
type MoveDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MoveDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MoveDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MoveDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MoveDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MoveDepartmentReplyValidationError) ErrorName() string {
	return "MoveDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e MoveDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMoveDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MoveDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MoveDepartmentReplyValidationError{}

// Validate checks the field values on MergeDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MergeDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MergeDepartmentReqMultiError, or nil if none found.
func (m *MergeDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	// no validation rules for ToDepartmentId

	if len(errors) > 0 {
		return MergeDepartmentReqMultiError(errors)
	}

	return nil
}

// MergeDepartmentReqMultiError is an error wrapping multiple validation errors
// returned by MergeDepartmentReq.ValidateAll() if the designated constraints
// aren't met.
type MergeDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeDepartmentReqMultiError) AllErrors() []error { return m }

// MergeDepartmentReqValidationError is the validation error returned by
// MergeDepartmentReq.Validate if the designated constraints aren't met.
type MergeDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeDepartmentReqValidationError) ErrorName() string {
	return "MergeDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e MergeDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeDepartmentReqValidationError{}

// Validate checks the field values on MergeDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MergeDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MergeDepartmentReplyMultiError, or nil if none found.
func (m *MergeDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeDepartmentReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeDepartmentReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MergeDepartmentReplyMultiError(errors)
	}

	return nil
}

// MergeDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by MergeDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type MergeDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeDepartmentReplyMultiError) AllErrors() []error { return m }

// MergeDepartmentReplyValidationError is the validation error returned by
// MergeDepartmentReply.Validate if the designated constraints aren't met.
type MergeDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeDepartmentReplyValidationError) ErrorName() string {
	return "MergeDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e MergeDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeDepartmentReplyValidationError{}

// Validate checks the field values on OrderDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderDepartmentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderDepartmentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderDepartmentReqMultiError, or nil if none found.
func (m *OrderDepartmentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderDepartmentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ParentId

	if len(errors) > 0 {
		return OrderDepartmentReqMultiError(errors)
	}

	return nil
}

// OrderDepartmentReqMultiError is an error wrapping multiple validation errors
// returned by OrderDepartmentReq.ValidateAll() if the designated constraints
// aren't met.
type OrderDepartmentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderDepartmentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderDepartmentReqMultiError) AllErrors() []error { return m }

// OrderDepartmentReqValidationError is the validation error returned by
// OrderDepartmentReq.Validate if the designated constraints aren't met.
type OrderDepartmentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderDepartmentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderDepartmentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderDepartmentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderDepartmentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderDepartmentReqValidationError) ErrorName() string {
	return "OrderDepartmentReqValidationError"
}

// Error satisfies the builtin error interface
func (e OrderDepartmentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderDepartmentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderDepartmentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderDepartmentReqValidationError{}

// Validate checks the field values on OrderDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderDepartmentReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderDepartmentReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderDepartmentReplyMultiError, or nil if none found.
func (m *OrderDepartmentReply) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderDepartmentReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OrderDepartmentReplyMultiError(errors)
	}

	return nil
}

// OrderDepartmentReplyMultiError is an error wrapping multiple validation
// errors returned by OrderDepartmentReply.ValidateAll() if the designated
// constraints aren't met.
type OrderDepartmentReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderDepartmentReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderDepartmentReplyMultiError) AllErrors() []error { return m }

// OrderDepartmentReplyValidationError is the validation error returned by
// OrderDepartmentReply.Validate if the designated constraints aren't met.
type OrderDepartmentReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderDepartmentReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderDepartmentReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderDepartmentReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderDepartmentReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderDepartmentReplyValidationError) ErrorName() string {
	return "OrderDepartmentReplyValidationError"
}

// Error satisfies the builtin error interface
func (e OrderDepartmentReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderDepartmentReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderDepartmentReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderDepartmentReplyValidationError{}

// Validate checks the field values on DepartmentInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DepartmentInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepartmentInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DepartmentInfoMultiError,
// or nil if none found.
func (m *DepartmentInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DepartmentInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepartmentId

	// no validation rules for DepartmentName

	// no validation rules for DepartmentDesc

	// no validation rules for DepartmentType

	// no validation rules for IsVirtual

	// no validation rules for ParentId

	// no validation rules for CompanyId

	// no validation rules for Depth

	// no validation rules for Seq

	// no validation rules for Status

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DepartmentInfoValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DepartmentInfoValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DepartmentInfoValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DepartmentInfoMultiError(errors)
	}

	return nil
}

// DepartmentInfoMultiError is an error wrapping multiple validation errors
// returned by DepartmentInfo.ValidateAll() if the designated constraints
// aren't met.
type DepartmentInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepartmentInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepartmentInfoMultiError) AllErrors() []error { return m }

// DepartmentInfoValidationError is the validation error returned by
// DepartmentInfo.Validate if the designated constraints aren't met.
type DepartmentInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepartmentInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepartmentInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepartmentInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepartmentInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepartmentInfoValidationError) ErrorName() string { return "DepartmentInfoValidationError" }

// Error satisfies the builtin error interface
func (e DepartmentInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepartmentInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepartmentInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepartmentInfoValidationError{}

// Validate checks the field values on CreateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateUserReqMultiError, or
// nil if none found.
func (m *CreateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	// no validation rules for DepartmentId

	// no validation rules for IsAdmin

	// no validation rules for IsVirtual

	// no validation rules for Phone

	// no validation rules for RealName

	// no validation rules for Email

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateUserReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateUserReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateUserReqValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateUserReqMultiError(errors)
	}

	return nil
}

// CreateUserReqMultiError is an error wrapping multiple validation errors
// returned by CreateUserReq.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReqMultiError) AllErrors() []error { return m }

// CreateUserReqValidationError is the validation error returned by
// CreateUserReq.Validate if the designated constraints aren't met.
type CreateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReqValidationError) ErrorName() string { return "CreateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReqValidationError{}

// Validate checks the field values on CreateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserReplyMultiError, or nil if none found.
func (m *CreateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserReplyMultiError(errors)
	}

	return nil
}

// CreateUserReplyMultiError is an error wrapping multiple validation errors
// returned by CreateUserReply.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReplyMultiError) AllErrors() []error { return m }

// CreateUserReplyValidationError is the validation error returned by
// CreateUserReply.Validate if the designated constraints aren't met.
type CreateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReplyValidationError) ErrorName() string { return "CreateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReplyValidationError{}

// Validate checks the field values on BatchCreateUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchCreateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchCreateUserReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchCreateUserReqMultiError, or nil if none found.
func (m *BatchCreateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchCreateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchCreateUserReqValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchCreateUserReqValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchCreateUserReqValidationError{
					field:  fmt.Sprintf("UserList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchCreateUserReqMultiError(errors)
	}

	return nil
}

// BatchCreateUserReqMultiError is an error wrapping multiple validation errors
// returned by BatchCreateUserReq.ValidateAll() if the designated constraints
// aren't met.
type BatchCreateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchCreateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchCreateUserReqMultiError) AllErrors() []error { return m }

// BatchCreateUserReqValidationError is the validation error returned by
// BatchCreateUserReq.Validate if the designated constraints aren't met.
type BatchCreateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchCreateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchCreateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchCreateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchCreateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchCreateUserReqValidationError) ErrorName() string {
	return "BatchCreateUserReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchCreateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchCreateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchCreateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchCreateUserReqValidationError{}

// Validate checks the field values on BatchCreateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchCreateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchCreateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchCreateUserReplyMultiError, or nil if none found.
func (m *BatchCreateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchCreateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetData()))
		i := 0
		for key := range m.GetData() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetData()[key]
			_ = val

			// no validation rules for Data[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BatchCreateUserReplyValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BatchCreateUserReplyValidationError{
							field:  fmt.Sprintf("Data[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BatchCreateUserReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return BatchCreateUserReplyMultiError(errors)
	}

	return nil
}

// BatchCreateUserReplyMultiError is an error wrapping multiple validation
// errors returned by BatchCreateUserReply.ValidateAll() if the designated
// constraints aren't met.
type BatchCreateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchCreateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchCreateUserReplyMultiError) AllErrors() []error { return m }

// BatchCreateUserReplyValidationError is the validation error returned by
// BatchCreateUserReply.Validate if the designated constraints aren't met.
type BatchCreateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchCreateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchCreateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchCreateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchCreateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchCreateUserReplyValidationError) ErrorName() string {
	return "BatchCreateUserReplyValidationError"
}

// Error satisfies the builtin error interface
func (e BatchCreateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchCreateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchCreateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchCreateUserReplyValidationError{}

// Validate checks the field values on DelUserReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DelUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DelUserReqMultiError, or
// nil if none found.
func (m *DelUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DelUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return DelUserReqMultiError(errors)
	}

	return nil
}

// DelUserReqMultiError is an error wrapping multiple validation errors
// returned by DelUserReq.ValidateAll() if the designated constraints aren't met.
type DelUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelUserReqMultiError) AllErrors() []error { return m }

// DelUserReqValidationError is the validation error returned by
// DelUserReq.Validate if the designated constraints aren't met.
type DelUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelUserReqValidationError) ErrorName() string { return "DelUserReqValidationError" }

// Error satisfies the builtin error interface
func (e DelUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelUserReqValidationError{}

// Validate checks the field values on DelUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DelUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DelUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DelUserReplyMultiError, or
// nil if none found.
func (m *DelUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DelUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return DelUserReplyMultiError(errors)
	}

	return nil
}

// DelUserReplyMultiError is an error wrapping multiple validation errors
// returned by DelUserReply.ValidateAll() if the designated constraints aren't met.
type DelUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DelUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DelUserReplyMultiError) AllErrors() []error { return m }

// DelUserReplyValidationError is the validation error returned by
// DelUserReply.Validate if the designated constraints aren't met.
type DelUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DelUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DelUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DelUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DelUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DelUserReplyValidationError) ErrorName() string { return "DelUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e DelUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DelUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DelUserReplyValidationError{}

// Validate checks the field values on UpdateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateUserReqMultiError, or
// nil if none found.
func (m *UpdateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for CompanyId

	// no validation rules for DepartmentId

	// no validation rules for IsAdmin

	// no validation rules for IsVirtual

	// no validation rules for Phone

	// no validation rules for RealName

	// no validation rules for Email

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateUserReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateUserReqValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateUserReqValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateUserReqMultiError(errors)
	}

	return nil
}

// UpdateUserReqMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReqMultiError) AllErrors() []error { return m }

// UpdateUserReqValidationError is the validation error returned by
// UpdateUserReq.Validate if the designated constraints aren't met.
type UpdateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReqValidationError) ErrorName() string { return "UpdateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReqValidationError{}

// Validate checks the field values on UpdateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserReplyMultiError, or nil if none found.
func (m *UpdateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateUserReplyValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateUserReplyValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateUserReplyValidationError{
					field:  fmt.Sprintf("UserList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateUserReplyMultiError(errors)
	}

	return nil
}

// UpdateUserReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReplyMultiError) AllErrors() []error { return m }

// UpdateUserReplyValidationError is the validation error returned by
// UpdateUserReply.Validate if the designated constraints aren't met.
type UpdateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReplyValidationError) ErrorName() string { return "UpdateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReplyValidationError{}

// Validate checks the field values on GetUserReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserReqMultiError, or
// nil if none found.
func (m *GetUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return GetUserReqMultiError(errors)
	}

	return nil
}

// GetUserReqMultiError is an error wrapping multiple validation errors
// returned by GetUserReq.ValidateAll() if the designated constraints aren't met.
type GetUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserReqMultiError) AllErrors() []error { return m }

// GetUserReqValidationError is the validation error returned by
// GetUserReq.Validate if the designated constraints aren't met.
type GetUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserReqValidationError) ErrorName() string { return "GetUserReqValidationError" }

// Error satisfies the builtin error interface
func (e GetUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserReqValidationError{}

// Validate checks the field values on GetUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserReplyMultiError, or
// nil if none found.
func (m *GetUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserReplyValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserReplyValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserReplyValidationError{
					field:  fmt.Sprintf("UserList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserReplyMultiError(errors)
	}

	return nil
}

// GetUserReplyMultiError is an error wrapping multiple validation errors
// returned by GetUserReply.ValidateAll() if the designated constraints aren't met.
type GetUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserReplyMultiError) AllErrors() []error { return m }

// GetUserReplyValidationError is the validation error returned by
// GetUserReply.Validate if the designated constraints aren't met.
type GetUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserReplyValidationError) ErrorName() string { return "GetUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserReplyValidationError{}

// Validate checks the field values on GetUserListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserListReqMultiError,
// or nil if none found.
func (m *GetUserListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageNum

	// no validation rules for DepartmentId

	if len(errors) > 0 {
		return GetUserListReqMultiError(errors)
	}

	return nil
}

// GetUserListReqMultiError is an error wrapping multiple validation errors
// returned by GetUserListReq.ValidateAll() if the designated constraints
// aren't met.
type GetUserListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserListReqMultiError) AllErrors() []error { return m }

// GetUserListReqValidationError is the validation error returned by
// GetUserListReq.Validate if the designated constraints aren't met.
type GetUserListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserListReqValidationError) ErrorName() string { return "GetUserListReqValidationError" }

// Error satisfies the builtin error interface
func (e GetUserListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserListReqValidationError{}

// Validate checks the field values on GetUserListReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetUserListReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserListReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserListReplyMultiError, or nil if none found.
func (m *GetUserListReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserListReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserListReplyValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	// no validation rules for PageSize

	// no validation rules for PageNum

	if len(errors) > 0 {
		return GetUserListReplyMultiError(errors)
	}

	return nil
}

// GetUserListReplyMultiError is an error wrapping multiple validation errors
// returned by GetUserListReply.ValidateAll() if the designated constraints
// aren't met.
type GetUserListReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserListReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserListReplyMultiError) AllErrors() []error { return m }

// GetUserListReplyValidationError is the validation error returned by
// GetUserListReply.Validate if the designated constraints aren't met.
type GetUserListReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserListReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserListReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserListReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserListReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserListReplyValidationError) ErrorName() string { return "GetUserListReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetUserListReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserListReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserListReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserListReplyValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBaseInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "BaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "BaseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "BaseInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExtraInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "ExtraInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtraInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "ExtraInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on UserInfo_ExtraInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserInfo_ExtraInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo_ExtraInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInfo_ExtraInfoMultiError, or nil if none found.
func (m *UserInfo_ExtraInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo_ExtraInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsVirtual

	// no validation rules for AreaId

	// no validation rules for DelFlag

	for idx, item := range m.GetExt() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserInfo_ExtraInfoValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserInfo_ExtraInfoValidationError{
						field:  fmt.Sprintf("Ext[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserInfo_ExtraInfoValidationError{
					field:  fmt.Sprintf("Ext[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return UserInfo_ExtraInfoMultiError(errors)
	}

	return nil
}

// UserInfo_ExtraInfoMultiError is an error wrapping multiple validation errors
// returned by UserInfo_ExtraInfo.ValidateAll() if the designated constraints
// aren't met.
type UserInfo_ExtraInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfo_ExtraInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfo_ExtraInfoMultiError) AllErrors() []error { return m }

// UserInfo_ExtraInfoValidationError is the validation error returned by
// UserInfo_ExtraInfo.Validate if the designated constraints aren't met.
type UserInfo_ExtraInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfo_ExtraInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfo_ExtraInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfo_ExtraInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfo_ExtraInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfo_ExtraInfoValidationError) ErrorName() string {
	return "UserInfo_ExtraInfoValidationError"
}

// Error satisfies the builtin error interface
func (e UserInfo_ExtraInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo_ExtraInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfo_ExtraInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfo_ExtraInfoValidationError{}

// Validate checks the field values on UserInfo_OrgInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserInfo_OrgInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo_OrgInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserInfo_OrgInfoMultiError, or nil if none found.
func (m *UserInfo_OrgInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo_OrgInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CompanyId

	// no validation rules for DepartmentId

	// no validation rules for IsAdmin

	// no validation rules for IsShow

	// no validation rules for DelFlag

	if len(errors) > 0 {
		return UserInfo_OrgInfoMultiError(errors)
	}

	return nil
}

// UserInfo_OrgInfoMultiError is an error wrapping multiple validation errors
// returned by UserInfo_OrgInfo.ValidateAll() if the designated constraints
// aren't met.
type UserInfo_OrgInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfo_OrgInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfo_OrgInfoMultiError) AllErrors() []error { return m }

// UserInfo_OrgInfoValidationError is the validation error returned by
// UserInfo_OrgInfo.Validate if the designated constraints aren't met.
type UserInfo_OrgInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfo_OrgInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfo_OrgInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfo_OrgInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfo_OrgInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfo_OrgInfoValidationError) ErrorName() string { return "UserInfo_OrgInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfo_OrgInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo_OrgInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfo_OrgInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfo_OrgInfoValidationError{}
