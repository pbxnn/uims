// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.1
// source: api/orgms/rpc/org.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CompanyClient is the client API for Company service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompanyClient interface {
	CreateCompany(ctx context.Context, in *CreateCompanyReq, opts ...grpc.CallOption) (*CreateCompanyReply, error)
	BatchCreateCompany(ctx context.Context, in *CreateCompanyReq, opts ...grpc.CallOption) (*BatchCreateCompanyReply, error)
	GetCompanyList(ctx context.Context, in *GetCompanyListReq, opts ...grpc.CallOption) (*GetCompanyListReply, error)
	GetCompany(ctx context.Context, in *GetCompanyReq, opts ...grpc.CallOption) (*GetCompanyReply, error)
	UpdateCompany(ctx context.Context, in *UpdateCompanyReq, opts ...grpc.CallOption) (*UpdateCompanyReply, error)
	DeleteCompany(ctx context.Context, in *DelCompanyReq, opts ...grpc.CallOption) (*DelCompanyReply, error)
	OrderCompany(ctx context.Context, in *OrderCompanyReq, opts ...grpc.CallOption) (*OrderCompanyReply, error)
}

type companyClient struct {
	cc grpc.ClientConnInterface
}

func NewCompanyClient(cc grpc.ClientConnInterface) CompanyClient {
	return &companyClient{cc}
}

func (c *companyClient) CreateCompany(ctx context.Context, in *CreateCompanyReq, opts ...grpc.CallOption) (*CreateCompanyReply, error) {
	out := new(CreateCompanyReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/CreateCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyClient) BatchCreateCompany(ctx context.Context, in *CreateCompanyReq, opts ...grpc.CallOption) (*BatchCreateCompanyReply, error) {
	out := new(BatchCreateCompanyReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/BatchCreateCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyClient) GetCompanyList(ctx context.Context, in *GetCompanyListReq, opts ...grpc.CallOption) (*GetCompanyListReply, error) {
	out := new(GetCompanyListReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/GetCompanyList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyClient) GetCompany(ctx context.Context, in *GetCompanyReq, opts ...grpc.CallOption) (*GetCompanyReply, error) {
	out := new(GetCompanyReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/GetCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyClient) UpdateCompany(ctx context.Context, in *UpdateCompanyReq, opts ...grpc.CallOption) (*UpdateCompanyReply, error) {
	out := new(UpdateCompanyReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/UpdateCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyClient) DeleteCompany(ctx context.Context, in *DelCompanyReq, opts ...grpc.CallOption) (*DelCompanyReply, error) {
	out := new(DelCompanyReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/DeleteCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *companyClient) OrderCompany(ctx context.Context, in *OrderCompanyReq, opts ...grpc.CallOption) (*OrderCompanyReply, error) {
	out := new(OrderCompanyReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Company/OrderCompany", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompanyServer is the server API for Company service.
// All implementations must embed UnimplementedCompanyServer
// for forward compatibility
type CompanyServer interface {
	CreateCompany(context.Context, *CreateCompanyReq) (*CreateCompanyReply, error)
	BatchCreateCompany(context.Context, *CreateCompanyReq) (*BatchCreateCompanyReply, error)
	GetCompanyList(context.Context, *GetCompanyListReq) (*GetCompanyListReply, error)
	GetCompany(context.Context, *GetCompanyReq) (*GetCompanyReply, error)
	UpdateCompany(context.Context, *UpdateCompanyReq) (*UpdateCompanyReply, error)
	DeleteCompany(context.Context, *DelCompanyReq) (*DelCompanyReply, error)
	OrderCompany(context.Context, *OrderCompanyReq) (*OrderCompanyReply, error)
	mustEmbedUnimplementedCompanyServer()
}

// UnimplementedCompanyServer must be embedded to have forward compatible implementations.
type UnimplementedCompanyServer struct {
}

func (UnimplementedCompanyServer) CreateCompany(context.Context, *CreateCompanyReq) (*CreateCompanyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCompany not implemented")
}
func (UnimplementedCompanyServer) BatchCreateCompany(context.Context, *CreateCompanyReq) (*BatchCreateCompanyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateCompany not implemented")
}
func (UnimplementedCompanyServer) GetCompanyList(context.Context, *GetCompanyListReq) (*GetCompanyListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompanyList not implemented")
}
func (UnimplementedCompanyServer) GetCompany(context.Context, *GetCompanyReq) (*GetCompanyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompany not implemented")
}
func (UnimplementedCompanyServer) UpdateCompany(context.Context, *UpdateCompanyReq) (*UpdateCompanyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCompany not implemented")
}
func (UnimplementedCompanyServer) DeleteCompany(context.Context, *DelCompanyReq) (*DelCompanyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCompany not implemented")
}
func (UnimplementedCompanyServer) OrderCompany(context.Context, *OrderCompanyReq) (*OrderCompanyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderCompany not implemented")
}
func (UnimplementedCompanyServer) mustEmbedUnimplementedCompanyServer() {}

// UnsafeCompanyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompanyServer will
// result in compilation errors.
type UnsafeCompanyServer interface {
	mustEmbedUnimplementedCompanyServer()
}

func RegisterCompanyServer(s grpc.ServiceRegistrar, srv CompanyServer) {
	s.RegisterService(&Company_ServiceDesc, srv)
}

func _Company_CreateCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCompanyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).CreateCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/CreateCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).CreateCompany(ctx, req.(*CreateCompanyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Company_BatchCreateCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCompanyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).BatchCreateCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/BatchCreateCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).BatchCreateCompany(ctx, req.(*CreateCompanyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Company_GetCompanyList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompanyListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).GetCompanyList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/GetCompanyList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).GetCompanyList(ctx, req.(*GetCompanyListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Company_GetCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompanyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).GetCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/GetCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).GetCompany(ctx, req.(*GetCompanyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Company_UpdateCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCompanyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).UpdateCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/UpdateCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).UpdateCompany(ctx, req.(*UpdateCompanyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Company_DeleteCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelCompanyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).DeleteCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/DeleteCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).DeleteCompany(ctx, req.(*DelCompanyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Company_OrderCompany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderCompanyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompanyServer).OrderCompany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Company/OrderCompany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompanyServer).OrderCompany(ctx, req.(*OrderCompanyReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Company_ServiceDesc is the grpc.ServiceDesc for Company service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Company_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "uims.orgms.api.Company",
	HandlerType: (*CompanyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCompany",
			Handler:    _Company_CreateCompany_Handler,
		},
		{
			MethodName: "BatchCreateCompany",
			Handler:    _Company_BatchCreateCompany_Handler,
		},
		{
			MethodName: "GetCompanyList",
			Handler:    _Company_GetCompanyList_Handler,
		},
		{
			MethodName: "GetCompany",
			Handler:    _Company_GetCompany_Handler,
		},
		{
			MethodName: "UpdateCompany",
			Handler:    _Company_UpdateCompany_Handler,
		},
		{
			MethodName: "DeleteCompany",
			Handler:    _Company_DeleteCompany_Handler,
		},
		{
			MethodName: "OrderCompany",
			Handler:    _Company_OrderCompany_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/orgms/rpc/org.proto",
}

// DepartmentClient is the client API for Department service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DepartmentClient interface {
	GetDepartment(ctx context.Context, in *GetDepartmentReq, opts ...grpc.CallOption) (*GetDepartmentReply, error)
	GetDepartmentList(ctx context.Context, in *GetDepartmentListReq, opts ...grpc.CallOption) (*GetCompanyListReply, error)
	CreateDepartment(ctx context.Context, in *CreateDepartmentReq, opts ...grpc.CallOption) (*CreateDepartmentReply, error)
	BatchCreateDepartment(ctx context.Context, in *BatchCreateDepartmentReq, opts ...grpc.CallOption) (*BatchCreateDepartmentReply, error)
	UpdateDepartment(ctx context.Context, in *UpdateDepartmentReq, opts ...grpc.CallOption) (*UpdateDepartmentReply, error)
	DeleteDepartment(ctx context.Context, in *DelDepartmentReq, opts ...grpc.CallOption) (*DelDepartmentReply, error)
	AssignDepartmentUser(ctx context.Context, in *AssignDepartmentUserReq, opts ...grpc.CallOption) (*AssignDepartmentUserReply, error)
	OrderDepartment(ctx context.Context, in *OrderDepartmentReq, opts ...grpc.CallOption) (*OrderDepartmentReply, error)
	MoveDepartment(ctx context.Context, in *MoveDepartmentReq, opts ...grpc.CallOption) (*MoveDepartmentReply, error)
	MergeDepartment(ctx context.Context, in *MergeDepartmentReq, opts ...grpc.CallOption) (*MergeDepartmentReply, error)
}

type departmentClient struct {
	cc grpc.ClientConnInterface
}

func NewDepartmentClient(cc grpc.ClientConnInterface) DepartmentClient {
	return &departmentClient{cc}
}

func (c *departmentClient) GetDepartment(ctx context.Context, in *GetDepartmentReq, opts ...grpc.CallOption) (*GetDepartmentReply, error) {
	out := new(GetDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/GetDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) GetDepartmentList(ctx context.Context, in *GetDepartmentListReq, opts ...grpc.CallOption) (*GetCompanyListReply, error) {
	out := new(GetCompanyListReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/GetDepartmentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) CreateDepartment(ctx context.Context, in *CreateDepartmentReq, opts ...grpc.CallOption) (*CreateDepartmentReply, error) {
	out := new(CreateDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/CreateDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) BatchCreateDepartment(ctx context.Context, in *BatchCreateDepartmentReq, opts ...grpc.CallOption) (*BatchCreateDepartmentReply, error) {
	out := new(BatchCreateDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/BatchCreateDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) UpdateDepartment(ctx context.Context, in *UpdateDepartmentReq, opts ...grpc.CallOption) (*UpdateDepartmentReply, error) {
	out := new(UpdateDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/UpdateDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) DeleteDepartment(ctx context.Context, in *DelDepartmentReq, opts ...grpc.CallOption) (*DelDepartmentReply, error) {
	out := new(DelDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/DeleteDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) AssignDepartmentUser(ctx context.Context, in *AssignDepartmentUserReq, opts ...grpc.CallOption) (*AssignDepartmentUserReply, error) {
	out := new(AssignDepartmentUserReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/AssignDepartmentUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) OrderDepartment(ctx context.Context, in *OrderDepartmentReq, opts ...grpc.CallOption) (*OrderDepartmentReply, error) {
	out := new(OrderDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/OrderDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) MoveDepartment(ctx context.Context, in *MoveDepartmentReq, opts ...grpc.CallOption) (*MoveDepartmentReply, error) {
	out := new(MoveDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/MoveDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentClient) MergeDepartment(ctx context.Context, in *MergeDepartmentReq, opts ...grpc.CallOption) (*MergeDepartmentReply, error) {
	out := new(MergeDepartmentReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.Department/MergeDepartment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DepartmentServer is the server API for Department service.
// All implementations must embed UnimplementedDepartmentServer
// for forward compatibility
type DepartmentServer interface {
	GetDepartment(context.Context, *GetDepartmentReq) (*GetDepartmentReply, error)
	GetDepartmentList(context.Context, *GetDepartmentListReq) (*GetCompanyListReply, error)
	CreateDepartment(context.Context, *CreateDepartmentReq) (*CreateDepartmentReply, error)
	BatchCreateDepartment(context.Context, *BatchCreateDepartmentReq) (*BatchCreateDepartmentReply, error)
	UpdateDepartment(context.Context, *UpdateDepartmentReq) (*UpdateDepartmentReply, error)
	DeleteDepartment(context.Context, *DelDepartmentReq) (*DelDepartmentReply, error)
	AssignDepartmentUser(context.Context, *AssignDepartmentUserReq) (*AssignDepartmentUserReply, error)
	OrderDepartment(context.Context, *OrderDepartmentReq) (*OrderDepartmentReply, error)
	MoveDepartment(context.Context, *MoveDepartmentReq) (*MoveDepartmentReply, error)
	MergeDepartment(context.Context, *MergeDepartmentReq) (*MergeDepartmentReply, error)
	mustEmbedUnimplementedDepartmentServer()
}

// UnimplementedDepartmentServer must be embedded to have forward compatible implementations.
type UnimplementedDepartmentServer struct {
}

func (UnimplementedDepartmentServer) GetDepartment(context.Context, *GetDepartmentReq) (*GetDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepartment not implemented")
}
func (UnimplementedDepartmentServer) GetDepartmentList(context.Context, *GetDepartmentListReq) (*GetCompanyListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepartmentList not implemented")
}
func (UnimplementedDepartmentServer) CreateDepartment(context.Context, *CreateDepartmentReq) (*CreateDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDepartment not implemented")
}
func (UnimplementedDepartmentServer) BatchCreateDepartment(context.Context, *BatchCreateDepartmentReq) (*BatchCreateDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateDepartment not implemented")
}
func (UnimplementedDepartmentServer) UpdateDepartment(context.Context, *UpdateDepartmentReq) (*UpdateDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDepartment not implemented")
}
func (UnimplementedDepartmentServer) DeleteDepartment(context.Context, *DelDepartmentReq) (*DelDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDepartment not implemented")
}
func (UnimplementedDepartmentServer) AssignDepartmentUser(context.Context, *AssignDepartmentUserReq) (*AssignDepartmentUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignDepartmentUser not implemented")
}
func (UnimplementedDepartmentServer) OrderDepartment(context.Context, *OrderDepartmentReq) (*OrderDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderDepartment not implemented")
}
func (UnimplementedDepartmentServer) MoveDepartment(context.Context, *MoveDepartmentReq) (*MoveDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveDepartment not implemented")
}
func (UnimplementedDepartmentServer) MergeDepartment(context.Context, *MergeDepartmentReq) (*MergeDepartmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MergeDepartment not implemented")
}
func (UnimplementedDepartmentServer) mustEmbedUnimplementedDepartmentServer() {}

// UnsafeDepartmentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DepartmentServer will
// result in compilation errors.
type UnsafeDepartmentServer interface {
	mustEmbedUnimplementedDepartmentServer()
}

func RegisterDepartmentServer(s grpc.ServiceRegistrar, srv DepartmentServer) {
	s.RegisterService(&Department_ServiceDesc, srv)
}

func _Department_GetDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).GetDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/GetDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).GetDepartment(ctx, req.(*GetDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_GetDepartmentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDepartmentListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).GetDepartmentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/GetDepartmentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).GetDepartmentList(ctx, req.(*GetDepartmentListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_CreateDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).CreateDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/CreateDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).CreateDepartment(ctx, req.(*CreateDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_BatchCreateDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).BatchCreateDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/BatchCreateDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).BatchCreateDepartment(ctx, req.(*BatchCreateDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_UpdateDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).UpdateDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/UpdateDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).UpdateDepartment(ctx, req.(*UpdateDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_DeleteDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).DeleteDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/DeleteDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).DeleteDepartment(ctx, req.(*DelDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_AssignDepartmentUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignDepartmentUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).AssignDepartmentUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/AssignDepartmentUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).AssignDepartmentUser(ctx, req.(*AssignDepartmentUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_OrderDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).OrderDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/OrderDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).OrderDepartment(ctx, req.(*OrderDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_MoveDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).MoveDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/MoveDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).MoveDepartment(ctx, req.(*MoveDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Department_MergeDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MergeDepartmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServer).MergeDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.Department/MergeDepartment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServer).MergeDepartment(ctx, req.(*MergeDepartmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Department_ServiceDesc is the grpc.ServiceDesc for Department service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Department_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "uims.orgms.api.Department",
	HandlerType: (*DepartmentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDepartment",
			Handler:    _Department_GetDepartment_Handler,
		},
		{
			MethodName: "GetDepartmentList",
			Handler:    _Department_GetDepartmentList_Handler,
		},
		{
			MethodName: "CreateDepartment",
			Handler:    _Department_CreateDepartment_Handler,
		},
		{
			MethodName: "BatchCreateDepartment",
			Handler:    _Department_BatchCreateDepartment_Handler,
		},
		{
			MethodName: "UpdateDepartment",
			Handler:    _Department_UpdateDepartment_Handler,
		},
		{
			MethodName: "DeleteDepartment",
			Handler:    _Department_DeleteDepartment_Handler,
		},
		{
			MethodName: "AssignDepartmentUser",
			Handler:    _Department_AssignDepartmentUser_Handler,
		},
		{
			MethodName: "OrderDepartment",
			Handler:    _Department_OrderDepartment_Handler,
		},
		{
			MethodName: "MoveDepartment",
			Handler:    _Department_MoveDepartment_Handler,
		},
		{
			MethodName: "MergeDepartment",
			Handler:    _Department_MergeDepartment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/orgms/rpc/org.proto",
}

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserReply, error)
	BatchCreateUser(ctx context.Context, in *BatchCreateUserReq, opts ...grpc.CallOption) (*BatchCreateUserReply, error)
	DelUser(ctx context.Context, in *DelUserReq, opts ...grpc.CallOption) (*DelUserReply, error)
	GetUserInfoReq(ctx context.Context, in *GetUserReq, opts ...grpc.CallOption) (*GetUserReply, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserReply, error) {
	out := new(CreateUserReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.User/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) BatchCreateUser(ctx context.Context, in *BatchCreateUserReq, opts ...grpc.CallOption) (*BatchCreateUserReply, error) {
	out := new(BatchCreateUserReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.User/BatchCreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) DelUser(ctx context.Context, in *DelUserReq, opts ...grpc.CallOption) (*DelUserReply, error) {
	out := new(DelUserReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.User/DelUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUserInfoReq(ctx context.Context, in *GetUserReq, opts ...grpc.CallOption) (*GetUserReply, error) {
	out := new(GetUserReply)
	err := c.cc.Invoke(ctx, "/uims.orgms.api.User/GetUserInfoReq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	CreateUser(context.Context, *CreateUserReq) (*CreateUserReply, error)
	BatchCreateUser(context.Context, *BatchCreateUserReq) (*BatchCreateUserReply, error)
	DelUser(context.Context, *DelUserReq) (*DelUserReply, error)
	GetUserInfoReq(context.Context, *GetUserReq) (*GetUserReply, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) CreateUser(context.Context, *CreateUserReq) (*CreateUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServer) BatchCreateUser(context.Context, *BatchCreateUserReq) (*BatchCreateUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateUser not implemented")
}
func (UnimplementedUserServer) DelUser(context.Context, *DelUserReq) (*DelUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelUser not implemented")
}
func (UnimplementedUserServer) GetUserInfoReq(context.Context, *GetUserReq) (*GetUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfoReq not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.User/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).CreateUser(ctx, req.(*CreateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_BatchCreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).BatchCreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.User/BatchCreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).BatchCreateUser(ctx, req.(*BatchCreateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_DelUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).DelUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.User/DelUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).DelUser(ctx, req.(*DelUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUserInfoReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserInfoReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uims.orgms.api.User/GetUserInfoReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserInfoReq(ctx, req.(*GetUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "uims.orgms.api.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _User_CreateUser_Handler,
		},
		{
			MethodName: "BatchCreateUser",
			Handler:    _User_BatchCreateUser_Handler,
		},
		{
			MethodName: "DelUser",
			Handler:    _User_DelUser_Handler,
		},
		{
			MethodName: "GetUserInfoReq",
			Handler:    _User_GetUserInfoReq_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/orgms/rpc/org.proto",
}
